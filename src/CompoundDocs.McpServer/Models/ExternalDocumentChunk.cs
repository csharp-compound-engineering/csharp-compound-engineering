using Microsoft.Extensions.VectorData;

namespace CompoundDocs.McpServer.Models;

/// <summary>
/// Represents a chunk of a large external document (>500 lines) for semantic search.
/// Parent external document reference maintained for context retrieval.
/// </summary>
/// <remarks>
/// External documents exceeding 500 lines are split into semantic chunks based on
/// markdown headers. Each chunk maintains a reference to its parent external document
/// and inherits the parent's namespace prefix.
///
/// Unlike DocumentChunk, ExternalDocumentChunk does not have a PromotionLevel
/// since external documents are read-only reference material.
/// </remarks>
public sealed class ExternalDocumentChunk
{
    /// <summary>
    /// Unique identifier for the chunk (GUID string).
    /// </summary>
    [VectorStoreKey]
    public string Id { get; set; } = Guid.NewGuid().ToString();

    #region Parent Reference

    /// <summary>
    /// Reference to the parent external document's ID.
    /// Used for retrieving full document context.
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string ExternalDocumentId { get; set; } = string.Empty;

    #endregion

    #region Tenant Isolation (Inherited from Parent)

    /// <summary>
    /// Composite tenant key for multi-tenant isolation.
    /// Inherited from parent external document.
    /// Format: project_name:branch_name:path_hash
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string TenantKey { get; set; } = string.Empty;

    #endregion

    #region Chunk Metadata

    /// <summary>
    /// Markdown header path representing the chunk's location in the document structure.
    /// Example: "## Configuration > ### Database Settings"
    /// </summary>
    [VectorStoreData]
    public string HeaderPath { get; set; } = string.Empty;

    /// <summary>
    /// Starting line number of this chunk in the source document (1-indexed).
    /// </summary>
    [VectorStoreData]
    public int StartLine { get; set; }

    /// <summary>
    /// Ending line number of this chunk in the source document (1-indexed, inclusive).
    /// </summary>
    [VectorStoreData]
    public int EndLine { get; set; }

    /// <summary>
    /// Content of this chunk for retrieval.
    /// </summary>
    [VectorStoreData]
    public string Content { get; set; } = string.Empty;

    /// <summary>
    /// Namespace prefix inherited from parent external document.
    /// Enables filtering by documentation source/category.
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string NamespacePrefix { get; set; } = "external";

    #endregion

    #region Vector Embedding

    /// <summary>
    /// Vector embedding generated by mxbai-embed-large (1024 dimensions).
    /// Uses cosine distance with HNSW index for efficient similarity search.
    /// </summary>
    [VectorStoreVector(Dimensions: 1024)]
    public ReadOnlyMemory<float>? Vector { get; set; }

    #endregion

    /// <summary>
    /// Creates a new chunk from a parent external document.
    /// </summary>
    /// <param name="parent">The parent external document.</param>
    /// <param name="headerPath">The markdown header path.</param>
    /// <param name="content">The chunk content.</param>
    /// <param name="startLine">Starting line number.</param>
    /// <param name="endLine">Ending line number.</param>
    /// <returns>A new ExternalDocumentChunk instance.</returns>
    public static ExternalDocumentChunk CreateFromParent(
        ExternalDocument parent,
        string headerPath,
        string content,
        int startLine,
        int endLine)
    {
        return new ExternalDocumentChunk
        {
            ExternalDocumentId = parent.Id,
            TenantKey = parent.TenantKey,
            HeaderPath = headerPath,
            Content = content,
            StartLine = startLine,
            EndLine = endLine,
            NamespacePrefix = parent.NamespacePrefix
        };
    }

    /// <summary>
    /// Gets the line count of this chunk.
    /// </summary>
    public int LineCount => EndLine - StartLine + 1;
}
