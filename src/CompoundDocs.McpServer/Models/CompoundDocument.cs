using Microsoft.Extensions.VectorData;

namespace CompoundDocs.McpServer.Models;

/// <summary>
/// Represents a compound document stored in the vector database.
/// Schema created automatically by Semantic Kernel's EnsureCollectionExistsAsync().
/// </summary>
/// <remarks>
/// Multi-tenant isolation is achieved through a composite tenant key:
/// Format: project_name:branch_name:path_hash
///
/// Properties marked with IsIndexed = true are indexed for efficient filtering.
/// The vector embedding uses HNSW index with cosine distance for similarity search.
/// </remarks>
public sealed class CompoundDocument
{
    /// <summary>
    /// Unique identifier for the document (GUID string).
    /// </summary>
    [VectorStoreKey]
    public string Id { get; set; } = Guid.NewGuid().ToString();

    #region Tenant Isolation

    /// <summary>
    /// Composite tenant key for multi-tenant isolation.
    /// Format: project_name:branch_name:path_hash
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string TenantKey { get; set; } = string.Empty;

    #endregion

    #region Document Metadata

    /// <summary>
    /// Document title extracted from frontmatter or first heading.
    /// </summary>
    [VectorStoreData]
    public string Title { get; set; } = string.Empty;

    /// <summary>
    /// Full content of the document for retrieval.
    /// </summary>
    [VectorStoreData]
    public string Content { get; set; } = string.Empty;

    /// <summary>
    /// Document type identifier (e.g., "spec", "adr", "research", "doc").
    /// Filterable to enable type-specific queries.
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string DocType { get; set; } = string.Empty;

    /// <summary>
    /// Promotion level for RAG prioritization.
    /// Values: "standard" (default), "promoted", "pinned"
    /// Higher levels receive boost in search results.
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string PromotionLevel { get; set; } = PromotionLevels.Standard;

    /// <summary>
    /// Relative path from the repository root to the document.
    /// </summary>
    [VectorStoreData]
    public string FilePath { get; set; } = string.Empty;

    /// <summary>
    /// Last modified timestamp of the source file.
    /// </summary>
    [VectorStoreData]
    public DateTimeOffset LastModified { get; set; } = DateTimeOffset.UtcNow;

    /// <summary>
    /// JSON-serialized array of document links for graph traversal.
    /// Contains relative paths to linked documents.
    /// </summary>
    [VectorStoreData]
    public string? Links { get; set; }

    #endregion

    #region Vector Embedding

    /// <summary>
    /// Vector embedding generated by mxbai-embed-large (1024 dimensions).
    /// Uses cosine distance with HNSW index for efficient similarity search.
    /// </summary>
    [VectorStoreVector(Dimensions: 1024)]
    public ReadOnlyMemory<float>? Vector { get; set; }

    #endregion

    /// <summary>
    /// Creates a tenant key from component parts.
    /// </summary>
    /// <param name="projectName">The project name.</param>
    /// <param name="branchName">The git branch name.</param>
    /// <param name="pathHash">The hash of the worktree path.</param>
    /// <returns>A composite tenant key.</returns>
    public static string CreateTenantKey(string projectName, string branchName, string pathHash)
    {
        return $"{projectName}:{branchName}:{pathHash}";
    }

    /// <summary>
    /// Parses a tenant key into its component parts.
    /// Uses split with limit of 3 to ensure any extra colons are captured in pathHash.
    /// </summary>
    /// <param name="tenantKey">The composite tenant key.</param>
    /// <returns>A tuple containing (projectName, branchName, pathHash).</returns>
    public static (string ProjectName, string BranchName, string PathHash) ParseTenantKey(string tenantKey)
    {
        var parts = tenantKey.Split(':', 3);
        if (parts.Length != 3)
        {
            throw new ArgumentException($"Invalid tenant key format: {tenantKey}", nameof(tenantKey));
        }
        return (parts[0], parts[1], parts[2]);
    }
}

/// <summary>
/// Defines valid promotion levels for compound documents.
/// Higher promotion levels receive priority in RAG queries.
/// </summary>
public static class PromotionLevels
{
    /// <summary>
    /// Standard documents appear in RAG results based on similarity score.
    /// </summary>
    public const string Standard = "standard";

    /// <summary>
    /// Promoted documents receive a boost in RAG ranking.
    /// </summary>
    public const string Promoted = "promoted";

    /// <summary>
    /// Pinned documents always appear at the top of RAG results.
    /// </summary>
    public const string Pinned = "pinned";

    /// <summary>
    /// All valid promotion levels.
    /// </summary>
    public static readonly IReadOnlyList<string> All = new[]
    {
        Standard,
        Promoted,
        Pinned
    };

    /// <summary>
    /// Validates that a promotion level string is valid.
    /// </summary>
    public static bool IsValid(string level) =>
        All.Contains(level, StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// Gets the boost factor for a promotion level.
    /// </summary>
    /// <param name="level">The promotion level.</param>
    /// <returns>A multiplier for similarity scores.</returns>
    public static float GetBoostFactor(string level) => level.ToLowerInvariant() switch
    {
        Standard => 1.0f,
        Promoted => 1.5f,
        Pinned => 2.0f,
        _ => 1.0f
    };
}

/// <summary>
/// Defines valid document types.
/// </summary>
public static class DocumentTypes
{
    /// <summary>
    /// Specification documents defining system behavior.
    /// </summary>
    public const string Spec = "spec";

    /// <summary>
    /// Architecture Decision Records.
    /// </summary>
    public const string Adr = "adr";

    /// <summary>
    /// Research documents with background information.
    /// </summary>
    public const string Research = "research";

    /// <summary>
    /// General documentation.
    /// </summary>
    public const string Doc = "doc";

    /// <summary>
    /// Problem statements and issue descriptions.
    /// </summary>
    public const string Problem = "problem";

    /// <summary>
    /// Insights and lessons learned.
    /// </summary>
    public const string Insight = "insight";

    /// <summary>
    /// Codebase documentation.
    /// </summary>
    public const string Codebase = "codebase";

    /// <summary>
    /// Tool documentation.
    /// </summary>
    public const string Tool = "tool";

    /// <summary>
    /// Style guides and coding standards.
    /// </summary>
    public const string Style = "style";

    /// <summary>
    /// All valid document types.
    /// </summary>
    public static readonly IReadOnlyList<string> All = new[]
    {
        Spec,
        Adr,
        Research,
        Doc,
        Problem,
        Insight,
        Codebase,
        Tool,
        Style
    };

    /// <summary>
    /// Validates that a document type string is valid.
    /// </summary>
    public static bool IsValid(string type) =>
        All.Contains(type, StringComparer.OrdinalIgnoreCase);
}
