using Microsoft.Extensions.VectorData;

namespace CompoundDocs.McpServer.Models;

/// <summary>
/// Represents a document from external documentation sources (read-only reference material).
/// External documents are stored in a separate collection from CompoundDocument to maintain
/// schema isolation and prevent external docs from appearing in RAG queries for institutional knowledge.
/// </summary>
/// <remarks>
/// External documents intentionally omit DocType and PromotionLevel fields:
/// - No DocType: External docs are generic reference material, not categorized
/// - No PromotionLevel: External docs are read-only, not subject to promotion workflow
///
/// Tenant isolation is achieved through composite tenant key:
/// Format: project_name:branch_name:path_hash
/// </remarks>
public sealed class ExternalDocument
{
    /// <summary>
    /// Unique identifier for the document (GUID string).
    /// </summary>
    [VectorStoreKey]
    public string Id { get; set; } = Guid.NewGuid().ToString();

    #region Tenant Isolation

    /// <summary>
    /// Composite tenant key for multi-tenant isolation.
    /// Format: project_name:branch_name:path_hash
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string TenantKey { get; set; } = string.Empty;

    #endregion

    #region Document Metadata

    /// <summary>
    /// Document title extracted from first H1 heading or filename.
    /// </summary>
    [VectorStoreData]
    public string Title { get; set; } = string.Empty;

    /// <summary>
    /// Full content of the document for retrieval.
    /// </summary>
    [VectorStoreData]
    public string Content { get; set; } = string.Empty;

    /// <summary>
    /// Relative path to the document within the external docs folder.
    /// </summary>
    [VectorStoreData]
    public string RelativePath { get; set; } = string.Empty;

    /// <summary>
    /// Source URL where the external document was fetched from.
    /// Used to track origin for re-synchronization.
    /// </summary>
    [VectorStoreData]
    public string? SourceUrl { get; set; }

    /// <summary>
    /// Last synchronization timestamp from the external source.
    /// Used for incremental sync operations.
    /// </summary>
    [VectorStoreData]
    public DateTimeOffset? LastSyncedAt { get; set; }

    /// <summary>
    /// Namespace prefix for categorizing external documents.
    /// Derived from the source configuration or defaults to "external".
    /// Enables filtering by documentation source/category.
    /// </summary>
    [VectorStoreData(IsIndexed = true)]
    public string NamespacePrefix { get; set; } = "external";

    /// <summary>
    /// SHA256 hash of document content for change detection.
    /// </summary>
    [VectorStoreData]
    public string ContentHash { get; set; } = string.Empty;

    /// <summary>
    /// Character count of the document content.
    /// </summary>
    [VectorStoreData]
    public int CharCount { get; set; }

    #endregion

    #region Vector Embedding

    /// <summary>
    /// Vector embedding generated by mxbai-embed-large (1024 dimensions).
    /// Uses cosine distance with HNSW index for efficient similarity search.
    /// </summary>
    [VectorStoreVector(Dimensions: 1024)]
    public ReadOnlyMemory<float>? Vector { get; set; }

    #endregion

    /// <summary>
    /// Creates a tenant key from component parts.
    /// </summary>
    /// <param name="projectName">The project name.</param>
    /// <param name="branchName">The git branch name.</param>
    /// <param name="pathHash">The hash of the worktree path.</param>
    /// <returns>A composite tenant key.</returns>
    public static string CreateTenantKey(string projectName, string branchName, string pathHash)
    {
        return $"{projectName}:{branchName}:{pathHash}";
    }

    /// <summary>
    /// Parses a tenant key into its component parts.
    /// Uses split with limit of 3 to ensure any extra colons are captured in pathHash.
    /// </summary>
    /// <param name="tenantKey">The composite tenant key.</param>
    /// <returns>A tuple containing (projectName, branchName, pathHash).</returns>
    public static (string ProjectName, string BranchName, string PathHash) ParseTenantKey(string tenantKey)
    {
        var parts = tenantKey.Split(':', 3);
        if (parts.Length != 3)
        {
            throw new ArgumentException($"Invalid tenant key format: {tenantKey}", nameof(tenantKey));
        }
        return (parts[0], parts[1], parts[2]);
    }
}
