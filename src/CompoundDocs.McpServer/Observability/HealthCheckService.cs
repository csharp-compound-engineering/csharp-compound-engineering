using System.Diagnostics;
using CompoundDocs.McpServer.Options;
using CompoundDocs.McpServer.SemanticKernel;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Npgsql;

namespace CompoundDocs.McpServer.Observability;

/// <summary>
/// Represents the health status of a dependency.
/// </summary>
public enum HealthStatus
{
    /// <summary>
    /// The dependency is healthy and responsive.
    /// </summary>
    Healthy,

    /// <summary>
    /// The dependency is degraded but still functional.
    /// </summary>
    Degraded,

    /// <summary>
    /// The dependency is unhealthy or unreachable.
    /// </summary>
    Unhealthy
}

/// <summary>
/// Represents the result of a health check for a single dependency.
/// </summary>
public sealed class HealthCheckResult
{
    /// <summary>
    /// The name of the dependency being checked.
    /// </summary>
    public required string Name { get; init; }

    /// <summary>
    /// The health status of the dependency.
    /// </summary>
    public required HealthStatus Status { get; init; }

    /// <summary>
    /// Additional description or error message.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// The time taken to perform the health check in milliseconds.
    /// </summary>
    public long DurationMs { get; init; }

    /// <summary>
    /// The timestamp when the check was performed.
    /// </summary>
    public DateTimeOffset CheckedAt { get; init; } = DateTimeOffset.UtcNow;
}

/// <summary>
/// Represents the overall health status of the system.
/// </summary>
public sealed class SystemHealthReport
{
    /// <summary>
    /// The overall health status of the system.
    /// </summary>
    public required HealthStatus OverallStatus { get; init; }

    /// <summary>
    /// Individual health check results for each dependency.
    /// </summary>
    public required IReadOnlyList<HealthCheckResult> Checks { get; init; }

    /// <summary>
    /// The timestamp when the report was generated.
    /// </summary>
    public DateTimeOffset GeneratedAt { get; init; } = DateTimeOffset.UtcNow;

    /// <summary>
    /// Total duration of all health checks in milliseconds.
    /// </summary>
    public long TotalDurationMs { get; init; }
}

/// <summary>
/// Background service that runs periodic health checks on system dependencies.
/// Checks PostgreSQL connectivity, Ollama connectivity, and vector store availability.
/// </summary>
public sealed class HealthCheckService : BackgroundService, IDisposable
{
    private readonly ILogger<HealthCheckService> _logger;
    private readonly IOptions<CompoundDocsServerOptions> _options;
    private readonly VectorStoreFactory _vectorStoreFactory;
    private readonly HttpClient _httpClient;

    private readonly TimeSpan _checkInterval = TimeSpan.FromSeconds(60);
    private readonly TimeSpan _checkTimeout = TimeSpan.FromSeconds(10);

    private SystemHealthReport? _lastHealthReport;
    private readonly object _reportLock = new();

    /// <summary>
    /// Gets the last health report generated by the service.
    /// </summary>
    public SystemHealthReport? LastHealthReport
    {
        get
        {
            lock (_reportLock)
            {
                return _lastHealthReport;
            }
        }
    }

    /// <summary>
    /// Creates a new instance of the HealthCheckService.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <param name="options">Server options containing connection configuration.</param>
    /// <param name="vectorStoreFactory">Factory for vector store operations.</param>
    /// <param name="httpClientFactory">HTTP client factory for Ollama checks.</param>
    public HealthCheckService(
        ILogger<HealthCheckService> logger,
        IOptions<CompoundDocsServerOptions> options,
        VectorStoreFactory vectorStoreFactory,
        IHttpClientFactory httpClientFactory)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _options = options ?? throw new ArgumentNullException(nameof(options));
        _vectorStoreFactory = vectorStoreFactory ?? throw new ArgumentNullException(nameof(vectorStoreFactory));
        _httpClient = httpClientFactory?.CreateClient("HealthCheck") ?? throw new ArgumentNullException(nameof(httpClientFactory));
        _httpClient.Timeout = _checkTimeout;
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("HealthCheckService starting, check interval: {Interval}s", _checkInterval.TotalSeconds);

        // Perform initial health check immediately
        await PerformHealthChecksAsync(stoppingToken);

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(_checkInterval, stoppingToken);
                await PerformHealthChecksAsync(stoppingToken);
            }
            catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)
            {
                // Expected during shutdown
                _logger.LogDebug("HealthCheckService stopping due to cancellation");
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during health check cycle");
            }
        }
    }

    /// <summary>
    /// Performs all health checks and returns a comprehensive health report.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The system health report.</returns>
    public async Task<SystemHealthReport> PerformHealthChecksAsync(CancellationToken cancellationToken = default)
    {
        var stopwatch = Stopwatch.StartNew();
        var checks = new List<HealthCheckResult>();

        _logger.LogDebug("Starting health checks");

        // Check PostgreSQL
        var postgresCheck = await CheckPostgreSqlAsync(cancellationToken);
        checks.Add(postgresCheck);

        // Check Ollama
        var ollamaCheck = await CheckOllamaAsync(cancellationToken);
        checks.Add(ollamaCheck);

        // Check Vector Store
        var vectorStoreCheck = await CheckVectorStoreAsync(cancellationToken);
        checks.Add(vectorStoreCheck);

        stopwatch.Stop();

        // Determine overall status
        var overallStatus = DetermineOverallStatus(checks);

        var report = new SystemHealthReport
        {
            OverallStatus = overallStatus,
            Checks = checks.AsReadOnly(),
            TotalDurationMs = stopwatch.ElapsedMilliseconds
        };

        // Store the report
        lock (_reportLock)
        {
            _lastHealthReport = report;
        }

        // Log the results
        LogHealthReport(report);

        return report;
    }

    private async Task<HealthCheckResult> CheckPostgreSqlAsync(CancellationToken cancellationToken)
    {
        var stopwatch = Stopwatch.StartNew();
        try
        {
            var connectionString = _options.Value.Postgres.GetConnectionString();
            await using var connection = new NpgsqlConnection(connectionString);
            await connection.OpenAsync(cancellationToken);

            // Execute a simple query to verify the connection works
            await using var cmd = new NpgsqlCommand("SELECT 1", connection);
            await cmd.ExecuteScalarAsync(cancellationToken);

            stopwatch.Stop();
            return new HealthCheckResult
            {
                Name = "PostgreSQL",
                Status = HealthStatus.Healthy,
                Description = $"Connected to {_options.Value.Postgres.Host}:{_options.Value.Postgres.Port}",
                DurationMs = stopwatch.ElapsedMilliseconds
            };
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogWarning(ex, "PostgreSQL health check failed");
            return new HealthCheckResult
            {
                Name = "PostgreSQL",
                Status = HealthStatus.Unhealthy,
                Description = $"Connection failed: {ex.Message}",
                DurationMs = stopwatch.ElapsedMilliseconds
            };
        }
    }

    private async Task<HealthCheckResult> CheckOllamaAsync(CancellationToken cancellationToken)
    {
        var stopwatch = Stopwatch.StartNew();
        try
        {
            var endpoint = _options.Value.Ollama.GetEndpoint();
            var healthUrl = new Uri(endpoint, "/api/tags");

            using var response = await _httpClient.GetAsync(healthUrl, cancellationToken);
            stopwatch.Stop();

            if (response.IsSuccessStatusCode)
            {
                return new HealthCheckResult
                {
                    Name = "Ollama",
                    Status = HealthStatus.Healthy,
                    Description = $"Connected to {endpoint}",
                    DurationMs = stopwatch.ElapsedMilliseconds
                };
            }

            return new HealthCheckResult
            {
                Name = "Ollama",
                Status = HealthStatus.Degraded,
                Description = $"Unexpected status code: {response.StatusCode}",
                DurationMs = stopwatch.ElapsedMilliseconds
            };
        }
        catch (TaskCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            throw;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogWarning(ex, "Ollama health check failed");
            return new HealthCheckResult
            {
                Name = "Ollama",
                Status = HealthStatus.Unhealthy,
                Description = $"Connection failed: {ex.Message}",
                DurationMs = stopwatch.ElapsedMilliseconds
            };
        }
    }

    private async Task<HealthCheckResult> CheckVectorStoreAsync(CancellationToken cancellationToken)
    {
        var stopwatch = Stopwatch.StartNew();
        try
        {
            // Try to verify that vector store collections exist
            await using var connection = await _vectorStoreFactory.DataSource.OpenConnectionAsync(cancellationToken);

            // Check if the pgvector extension is available
            await using var cmd = new NpgsqlCommand(
                "SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname = 'vector')",
                connection);

            var hasVector = (bool?)await cmd.ExecuteScalarAsync(cancellationToken) ?? false;

            stopwatch.Stop();

            if (hasVector)
            {
                return new HealthCheckResult
                {
                    Name = "VectorStore",
                    Status = HealthStatus.Healthy,
                    Description = "pgvector extension is available",
                    DurationMs = stopwatch.ElapsedMilliseconds
                };
            }

            return new HealthCheckResult
            {
                Name = "VectorStore",
                Status = HealthStatus.Degraded,
                Description = "pgvector extension not found",
                DurationMs = stopwatch.ElapsedMilliseconds
            };
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogWarning(ex, "Vector store health check failed");
            return new HealthCheckResult
            {
                Name = "VectorStore",
                Status = HealthStatus.Unhealthy,
                Description = $"Check failed: {ex.Message}",
                DurationMs = stopwatch.ElapsedMilliseconds
            };
        }
    }

    private static HealthStatus DetermineOverallStatus(IReadOnlyList<HealthCheckResult> checks)
    {
        if (checks.All(c => c.Status == HealthStatus.Healthy))
        {
            return HealthStatus.Healthy;
        }

        if (checks.Any(c => c.Status == HealthStatus.Unhealthy))
        {
            return HealthStatus.Unhealthy;
        }

        return HealthStatus.Degraded;
    }

    private void LogHealthReport(SystemHealthReport report)
    {
        var statusEmoji = report.OverallStatus switch
        {
            HealthStatus.Healthy => "OK",
            HealthStatus.Degraded => "WARN",
            HealthStatus.Unhealthy => "FAIL",
            _ => "UNKNOWN"
        };

        _logger.LogInformation(
            "Health check completed [{Status}] in {Duration}ms",
            statusEmoji,
            report.TotalDurationMs);

        foreach (var check in report.Checks)
        {
            var level = check.Status switch
            {
                HealthStatus.Healthy => LogLevel.Debug,
                HealthStatus.Degraded => LogLevel.Warning,
                HealthStatus.Unhealthy => LogLevel.Error,
                _ => LogLevel.Information
            };

            _logger.Log(
                level,
                "  {CheckName}: {Status} - {Description} ({Duration}ms)",
                check.Name,
                check.Status,
                check.Description,
                check.DurationMs);
        }
    }

    /// <inheritdoc />
    public override void Dispose()
    {
        _httpClient.Dispose();
        base.Dispose();
    }
}
